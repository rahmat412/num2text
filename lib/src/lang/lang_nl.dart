import 'package:decimal/decimal.dart';

import '../concurencies/concurencies_info.dart';
import '../num2text_base.dart';
import '../options/base_options.dart';
import '../options/nl_options.dart';
import '../utils/utils.dart';

/// {@template num2text_nl}
/// The Dutch language (`Lang.NL`) implementation for converting numbers to words.
///
/// Implements the [Num2TextBase] contract, accepting various numeric inputs (`int`, `double`,
/// `BigInt`, `Decimal`, `String`) via its `process` method. It converts these inputs
/// into their Dutch word representation following standard Dutch grammar and vocabulary.
///
/// Capabilities include handling cardinal numbers, currency (using [NlOptions.currencyInfo]),
/// year formatting ([Format.year]), negative numbers, decimals, and large numbers
/// (using a million/billion/trillion scale system, including 'miljard', 'biljard', etc.).
/// Invalid inputs result in a fallback message.
///
/// Behavior can be customized using [NlOptions].
/// {@endtemplate}
class Num2TextNL implements Num2TextBase {
  /// Word for the decimal point ".".
  static const String _point = "punt";

  /// Word for the decimal comma ",".
  static const String _comma = "komma";

  /// Conjunction "and".
  static const String _and = "en";

  /// Word for "hundred".
  static const String _hundred = "honderd";

  /// Word for "thousand".
  static const String _thousand = "duizend";

  /// Suffix for BC years ("voor Christus").
  static const String _yearSuffixBC = "v.Chr.";

  /// Suffix for AD/CE years ("na Christus").
  static const String _yearSuffixAD = "n.Chr.";

  /// Dutch words for numbers 0 through 19.
  static const List<String> _wordsUnder20 = [
    "nul", // 0
    "één", // 1 (special case: "een" used in compounds)
    "twee", // 2
    "drie", // 3
    "vier", // 4
    "vijf", // 5
    "zes", // 6
    "zeven", // 7
    "acht", // 8
    "negen", // 9
    "tien", // 10
    "elf", // 11
    "twaalf", // 12
    "dertien", // 13
    "veertien", // 14
    "vijftien", // 15
    "zestien", // 16
    "zeventien", // 17
    "achtien", // 18
    "negentien", // 19
  ];

  /// Dutch words for multiples of ten from 20 to 90.
  /// Indices 0 and 1 are unused.
  static const List<String> _wordsTens = [
    "", // 0 (unused)
    "", // 10 (unused, covered by _wordsUnder20)
    "twintig", // 20
    "dertig", // 30
    "veertig", // 40
    "vijftig", // 50
    "zestig", // 60
    "zeventig", // 70
    "tachtig", // 80
    "negentig", // 90
  ];

  /// Pre-computed map for numbers 21-99, combining units and tens according to Dutch rules.
  /// Example: 21 -> "eenentwintig", 43 -> "drieënveertig".
  /// Generated by [_generateTensUnits].
  static final Map<int, String> _wordsTensUnits = _generateTensUnits();

  /// Defines the large number scale words (million, billion, etc.) used in Dutch.
  /// The key represents the power of 1000 (index):
  /// 2: 1000^2 = million
  /// 3: 1000^3 = billion (miljard)
  /// 4: 1000^4 = trillion (biljoen)
  /// etc.
  static const Map<int, String> _scaleWords = {
    2: "miljoen", // 10^6
    3: "miljard", // 10^9
    4: "biljoen", // 10^12
    5: "biljard", // 10^15
    6: "triljoen", // 10^18
    7: "triljard", // 10^21
    8: "quadriljoen", // 10^24
    9: "quadriljard", // 10^27
    // Add more scales if needed
  };

  /// Generates the [_wordsTensUnits] map for numbers 21-99.
  ///
  /// Iterates through tens (20-90) and units (1-9), combining them
  /// according to Dutch compound number rules: "unit{conjunction}ten".
  /// Uses "een" for unit 1, and the correct conjunction ("en" or "ën" for 2, 3).
  static Map<int, String> _generateTensUnits() {
    final map = <int, String>{};
    // Loop through tens digits (2 to 9).
    for (int t = 2; t <= 9; t++) {
      String tenWord = _wordsTens[t]; // e.g., "twintig"
      // Loop through unit digits (1 to 9).
      for (int u = 1; u <= 9; u++) {
        String unitWord;
        // Use "een" for 1, otherwise use the standard word from _wordsUnder20.
        if (u == 1) {
          unitWord = "een";
        } else {
          unitWord = _wordsUnder20[u]; // e.g., "twee", "drie"
        }
        // Determine the conjunction: "ën" for units 2 and 3, "en" otherwise.
        String conjunction = (u == 2 || u == 3) ? "ën" : "en";
        // Combine: unit + conjunction + ten. Store in the map.
        map[t * 10 + u] =
            "$unitWord$conjunction$tenWord"; // e.g., 21 -> "eenentwintig", 43 -> "drieënveertig"
      }
    }
    return map;
  }

  /// Processes the given [number] and converts it into Dutch words.
  ///
  /// This is the main entry point for the Dutch conversion.
  /// - It normalizes the input [number] (int, double, BigInt, String, Decimal) into a [Decimal].
  /// - Handles special cases like infinity and NaN for doubles.
  /// - Manages the negative sign using [NlOptions.negativePrefix].
  /// - Delegates the core conversion logic to helper methods based on [options]:
  ///   - [_handleYearFormat] for year format ([Format.year]).
  ///   - [_handleCurrency] if [NlOptions.currency] is true.
  ///   - [_handleStandardNumber] for regular cardinal numbers (including decimals).
  /// - Returns the final word representation or [fallbackOnError] / default error message.
  /// - Cleans up potential extra whitespace before returning.
  @override
  String process(
      dynamic number, BaseOptions? options, String? fallbackOnError) {
    // Ensure we have Dutch-specific options, using defaults if none are provided.
    final NlOptions nlOptions =
        options is NlOptions ? options : const NlOptions();

    // Handle special double values before normalization.
    if (number is double) {
      if (number.isInfinite)
        return number.isNegative ? "Negatieve oneindigheid" : "Oneindig";
      if (number.isNaN)
        return fallbackOnError ?? "Geen getal"; // Return fallback or NaN word
    }

    // Normalize the input number to Decimal for precision.
    final Decimal? decimalValue = Utils.normalizeNumber(number);
    if (decimalValue == null) {
      return fallbackOnError ?? "Geen getal"; // Handle normalization failure
    }

    // Handle the specific case of zero.
    if (decimalValue == Decimal.zero) {
      if (nlOptions.currency) {
        // For currency, use "nul" and the plural (or singular if no plural) main unit name.
        return "${_wordsUnder20[0]} ${nlOptions.currencyInfo.mainUnitPlural ?? nlOptions.currencyInfo.mainUnitSingular}";
      } else {
        // Otherwise, just return the word for zero ("nul").
        return _wordsUnder20[0];
      }
    }

    // Determine sign and work with the absolute value.
    final bool isNegative = decimalValue.isNegative;
    final Decimal absValue = isNegative ? -decimalValue : decimalValue;

    String textResult;
    // Delegate based on the format specified in options.
    if (nlOptions.format == Format.year) {
      // Handle year formatting (may include BC/AD suffixes).
      // Note: Year handling assumes the year fits within a standard int.
      textResult = _handleYearFormat(
          decimalValue.truncate().toBigInt().toInt(), nlOptions);
    } else {
      // Handle non-year formats (currency or standard number).
      if (nlOptions.currency) {
        textResult = _handleCurrency(absValue, nlOptions);
      } else {
        textResult = _handleStandardNumber(absValue, nlOptions);
      }
      // Prepend the negative prefix if the original number was negative (only for non-year formats).
      if (isNegative) {
        textResult = "${nlOptions.negativePrefix} $textResult";
      }
    }

    // Clean up multiple spaces and trim leading/trailing whitespace.
    return textResult.replaceAll(RegExp(r'\s+'), ' ').trim();
  }

  /// Formats an [year] integer as a Dutch year string.
  ///
  /// Handles negative years by appending "v.Chr." (BC).
  /// Handles positive years by optionally appending "n.Chr." (AD/CE) if [options.includeAD] is true.
  /// Uses special logic for years 1100-1999 (e.g., "negentienhonderd").
  /// Delegates to [_convertInteger] for other years.
  String _handleYearFormat(int year, NlOptions options) {
    final bool isNegative = year < 0;
    final int absYear = year.abs();
    final BigInt bigAbsYear = BigInt.from(
      absYear,
    ); // Use BigInt for consistency with _convertInteger
    String yearText;

    // Special handling for years between 1100 and 1999 (inclusive).
    if (absYear >= 1100 && absYear < 2000) {
      int highPartInt = absYear ~/ 100; // e.g., 19 for 19xx
      int lowPartInt = absYear % 100; // e.g., xx for 19xx
      String yearHighText = _wordsUnder20[highPartInt]; // e.g., "negentien"
      if (lowPartInt == 0) {
        // If the year ends in 00, format as "Xhonderd".
        yearText =
            "$yearHighText$_hundred"; // e.g., "negentienhonderd" for 1900
      } else {
        // If the year does not end in 00 (e.g., 1984), convert the full number normally.
        yearText = _convertInteger(
            bigAbsYear); // e.g., "negentienhonderdvierentachtig"
      }
    } else {
      // For years outside the 1100-1999 range, convert normally.
      yearText = _convertInteger(bigAbsYear);
    }

    // Append suffixes for BC or AD/AD.
    if (isNegative) {
      yearText += " $_yearSuffixBC"; // Append "v.Chr." for negative years.
    } else if (options.includeAD && year > 0) {
      // Append "n.Chr." only if the option is enabled and the year is positive.
      yearText += " $_yearSuffixAD";
    }
    return yearText;
  }

  /// Formats the absolute [absValue] as Dutch currency.
  ///
  /// Uses the [CurrencyInfo] provided in [options] to get unit names.
  /// Separates the main unit value and the subunit value (assumes 2 decimal places for subunits).
  /// Converts both parts to words using [_convertInteger].
  /// Joins the main and subunit parts with " en " and the appropriate unit names.
  String _handleCurrency(Decimal absValue, NlOptions options) {
    final CurrencyInfo currencyInfo = options.currencyInfo;
    // Get the integer part for the main currency unit (e.g., Euro).
    final BigInt mainValue = absValue.truncate().toBigInt();
    // Get the fractional part for the subunit (e.g., Cent).
    final Decimal fractionalPart = absValue - absValue.truncate();

    // Assume 2 decimal places for subunits (e.g., cents).
    final int subunitScale = 2;
    final BigInt subunitMultiplier = BigInt.from(10).pow(subunitScale);
    // Calculate the subunit value as an integer.
    final BigInt subunitValue =
        (fractionalPart * Decimal.fromBigInt(subunitMultiplier))
            .truncate()
            .toBigInt();

    // Convert the main value to words.
    String mainText = _convertInteger(mainValue);
    // Get the correct singular/plural form for the main unit.
    String mainUnitName = (mainValue == BigInt.one)
        ? currencyInfo.mainUnitSingular // Use singular if value is 1
        // Use plural if available, otherwise fallback to singular (handles currencies like Euro).
        : (currencyInfo.mainUnitPlural ?? currencyInfo.mainUnitSingular);

    // Start building the result string.
    String result = '$mainText $mainUnitName'; // e.g., "twaalf euro"

    // If there's a non-zero subunit value, add it.
    if (subunitValue > BigInt.zero) {
      // Convert subunit value to words.
      String subunitText = _convertInteger(subunitValue);
      // Get the subunit name (assuming singular is sufficient and defined).
      String subUnitName =
          currencyInfo.subUnitSingular ?? "?"; // Fallback if not defined

      // Append " en [subunit words] [subunit name]".
      result +=
          ' $_and $subunitText $subUnitName'; // e.g., " en vijfentwintig cent"
    }
    return result;
  }

  /// Formats the absolute [absValue] as a standard Dutch cardinal number, including decimals if present.
  ///
  /// Separates the integer and fractional parts.
  /// Converts the integer part using [_convertInteger].
  /// Converts the fractional part digit by digit, joined by spaces, prefixed by the appropriate decimal separator word ("punt" or "komma").
  /// Ensures fractional digits are padded with leading zeros based on the original number's scale.
  String _handleStandardNumber(Decimal absValue, NlOptions options) {
    // Get the integer part of the number.
    final BigInt integerPart = absValue.truncate().toBigInt();
    // Get the fractional part of the number.
    final Decimal fractionalPart = absValue - absValue.truncate();

    // Convert the integer part to words.
    // Handle the special case "0.xxx": if integer is 0 but there's a fractional part, output "nul".
    String integerWords =
        (integerPart == BigInt.zero && fractionalPart > Decimal.zero)
            ? _wordsUnder20[0] // Use "nul" for the integer part if it's 0.xxx
            : _convertInteger(
                integerPart); // Otherwise, convert the integer normally.

    String fractionalWords = '';

    // Process the fractional part if the original number had decimal places (scale > 0)
    // and the fractional part itself is non-negative (always true for absValue).
    if (absValue.scale > 0 && fractionalPart >= Decimal.zero) {
      // Only add decimal words if the fractional part is actually greater than zero,
      // OR if the integer part was zero and there were decimal places defined (e.g., 0.00).
      if (fractionalPart > Decimal.zero ||
          (integerPart == BigInt.zero && absValue.scale > 0)) {
        // Determine the separator word ("punt" or "komma") based on options.
        String separatorWord;
        switch (options.decimalSeparator) {
          case DecimalSeparator.point:
          case DecimalSeparator.period: // Treat period and point the same
            separatorWord = _point;
            break;
          case DecimalSeparator.comma:
          default: // Default to comma if null or comma
            separatorWord = _comma;
            break;
        }

        // Get the fractional digits as an integer (e.g., 0.123 -> 123).
        final BigInt digitsAsInt = (fractionalPart *
                Decimal.fromInt(10).pow(absValue.scale).toDecimal())
            .truncate()
            .toBigInt();
        // Convert the integer digits to a string.
        final String digitsString = digitsAsInt.toString();

        // Pad the string with leading zeros if necessary to match the original scale.
        // e.g., if scale is 3 and digitsAsInt is 5, padded becomes "005".
        final String paddedDigitsString =
            digitsString.padLeft(absValue.scale, '0');

        // Convert each digit character to its word representation.
        List<String> digitWords = paddedDigitsString.split('').map((digit) {
          final int digitInt = int.parse(digit);
          return _wordsUnder20[digitInt]; // Use words 0-9
        }).toList();

        // Combine the separator word and the spoken digits.
        fractionalWords =
            ' $separatorWord ${digitWords.join(' ')}'; // e.g., " komma nul nul vijf"
      }
    }

    // Combine integer and fractional parts, trimming any leading/trailing whitespace.
    return '$integerWords$fractionalWords'.trim();
  }

  /// Converts a non-negative [BigInt] [n] into its Dutch word representation.
  ///
  /// Handles numbers by breaking them down into chunks:
  /// 1. Numbers less than 1,000,000 are handled by [_convertLessThanMillion].
  /// 2. Larger numbers are processed recursively using the `_scaleWords` map
  ///    (miljoen, miljard, biljoen, etc.), calling this function again for the count
  ///    of each scale unit and [_convertLessThanMillion] for the final remainder.
  String _convertInteger(BigInt n) {
    // Input validation.
    if (n < BigInt.zero)
      throw ArgumentError("Integer must be non-negative: $n");
    if (n == BigInt.zero) return _wordsUnder20[0]; // Base case: zero is "nul".

    // Delegate small chunks to specialized functions.
    if (n < BigInt.from(1000)) return _convertChunk(n.toInt()); // 0-999
    if (n < BigInt.from(1000000))
      return _convertLessThanMillion(n); // 1000-999,999

    // Handle numbers >= 1,000,000 using scales.
    List<String> parts = []; // Stores word chunks for each scale.
    BigInt remainder = n; // The portion of the number still to be converted.

    // Determine the starting scale power (power of 10) based on the largest defined scale.
    // e.g., if quadriljard (10^27) is the largest, start with power 27 (index 9 * 3 = 27).
    int scalePower = _scaleWords.keys.last *
        3; // Power of 10 (e.g., 6 for million, 9 for billion)

    // Iterate downwards through the scales (million, billion, etc.).
    while (scalePower >= 6) {
      // Stop at million (power 6).
      final BigInt scaleValue =
          BigInt.from(10).pow(scalePower); // e.g., 10^9 for miljard
      final int scaleIndex =
          scalePower ~/ 3; // Index for _scaleWords map (e.g., 3 for miljard)

      // Check if this scale is defined in our map.
      if (_scaleWords.containsKey(scaleIndex)) {
        // Check if the remainder is large enough to contain this scale unit.
        if (remainder >= scaleValue) {
          // Calculate how many times this scale unit fits.
          BigInt chunkCount = remainder ~/ scaleValue;
          // Update the remainder.
          remainder %= scaleValue;
          // Recursively convert the count of this scale unit to words.
          String chunkText = _convertInteger(chunkCount);
          // Get the word for this scale unit (e.g., "miljoen").
          String scaleWord = _scaleWords[scaleIndex]!;
          // Add the formatted chunk (e.g., "twee miljoen") to the parts list.
          parts.add("$chunkText $scaleWord");
        }
      } else {
        // This case should theoretically not happen if scalePower logic is correct,
        // but could be used for error handling or logging if needed.
        // print("Scale index $scaleIndex not found for power $scalePower");
      }
      // Move to the next smaller scale (decrease power by 3).
      scalePower -= 3;
    }

    // After processing all scales >= million, convert the final remainder (which is < 1,000,000).
    if (remainder > BigInt.zero) {
      parts.add(_convertLessThanMillion(remainder));
    }

    // Join all collected parts with spaces, clean up extra whitespace, and trim.
    return parts.join(' ').replaceAll(RegExp(r'\s+'), ' ').trim();
  }

  /// Converts a [BigInt] [n] between 0 and 999,999 into Dutch words.
  ///
  /// Separates the number into the thousands part and the remainder (< 1000).
  /// Converts each part using [_convertChunk] and joins them with appropriate spacing.
  /// Handles the special case where the thousands part is exactly 1 ("duizend" vs "éénduizend").
  String _convertLessThanMillion(BigInt n) {
    // Input validation.
    if (n >= BigInt.from(1000000))
      throw ArgumentError("Number must be < 1,000,000: $n");
    if (n == BigInt.zero) return ""; // Return empty for zero input.

    List<String> parts = [];
    // Calculate the thousands part (0-999).
    final int thousandPart = (n ~/ BigInt.from(1000)).toInt();
    // Calculate the remainder part (0-999).
    final int remainderPart = (n % BigInt.from(1000)).toInt();

    // Process the thousands part if it's greater than zero.
    if (thousandPart > 0) {
      if (thousandPart == 1) {
        // Special case: If thousands part is 1, just use "duizend".
        parts.add(_thousand);
      } else {
        // Otherwise, convert the thousands count and append "duizend".
        // Use _convertChunk as thousandPart is guaranteed to be < 1000.
        parts.add(
          "${_convertChunk(thousandPart)}$_thousand",
        ); // e.g., "twee" + "duizend" -> "tweeduizend"
      }
    }

    // Process the remainder part if it's greater than zero.
    if (remainderPart > 0) {
      // Convert the remainder (0-999) using _convertChunk.
      parts.add(_convertChunk(remainderPart));
    }

    // Join the parts (thousand part and remainder part) with a space and trim.
    return parts.join(' ').trim();
  }

  /// Converts an integer [n] between 0 and 999 into its Dutch word representation.
  ///
  /// This is the base conversion function for 3-digit chunks.
  /// Handles hundreds place first, then the remaining 0-99 part using
  /// [_wordsUnder20], [_wordsTens], or the pre-computed [_wordsTensUnits] map.
  String _convertChunk(int n) {
    if (n == 0) return ""; // Return empty for zero input.
    // Input validation.
    if (n < 0 || n >= 1000) throw ArgumentError("Chunk must be 0-999: $n");

    List<String> words =
        []; // Stores parts of the chunk (hundreds, tens/units).
    int remainder = n;

    // Handle hundreds place.
    if (remainder >= 100) {
      int hundredMultiplier = remainder ~/ 100; // How many hundreds (1-9).
      // Special case for 100: "honderd". For 200+: "digit" + "honderd".
      words.add(hundredMultiplier == 1
          ? _hundred
          : "${_wordsUnder20[hundredMultiplier]}$_hundred");
      remainder %= 100; // Update remainder to the 0-99 part.
    }

    // Handle the remaining tens and units place (0-99).
    if (remainder > 0) {
      String tensUnitsPart;
      if (remainder < 20) {
        // If remainder is 0-19, use the direct lookup table.
        tensUnitsPart = _wordsUnder20[remainder];
      } else if (remainder % 10 == 0) {
        // If remainder is a multiple of 10 (20, 30,... 90), use the tens lookup table.
        tensUnitsPart = _wordsTens[remainder ~/ 10];
      } else {
        // If remainder is 21-99 (not multiple of 10), use the pre-computed map.
        tensUnitsPart =
            _wordsTensUnits[remainder]!; // Assumes map contains the key.
      }
      // Add the processed tens/units part to the words list.
      words.add(tensUnitsPart);
    }

    // Join the parts (at most, hundreds part and tens/units part) with a space and trim.
    return words.join(' ').trim();
  }
}
