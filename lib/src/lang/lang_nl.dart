import 'package:decimal/decimal.dart';

import '../concurencies/concurencies_info.dart';
import '../num2text_base.dart';
import '../options/base_options.dart';
import '../options/nl_options.dart';
import '../utils/utils.dart';

/// {@template num2text_nl}
/// Converts numbers to Dutch words (`Lang.NL`).
///
/// Implements [Num2TextBase] for Dutch, handling various numeric types.
/// Supports cardinal numbers, decimals, negatives, currency, years, and large numbers
/// (using million, miljard, biljoen scale). Follows Dutch grammar (e.g., "eenentwintig").
/// Customizable via [NlOptions]. Returns a fallback string on error.
/// {@endtemplate}
class Num2TextNL implements Num2TextBase {
  // --- Constants ---
  static const String _point = "punt"; // Decimal point "." word.
  static const String _comma = "komma"; // Decimal comma "," word.
  static const String _and = "en"; // Conjunction, used in currency.
  static const String _hundred = "honderd";
  static const String _thousand = "duizend";
  static const String _yearSuffixBC = "v.Chr."; // "voor Christus"
  static const String _yearSuffixAD = "n.Chr."; // "na Christus"

  static const List<String> _wordsUnder20 = [
    "nul",
    "één",
    "twee",
    "drie",
    "vier",
    "vijf",
    "zes",
    "zeven",
    "acht",
    "negen",
    "tien",
    "elf",
    "twaalf",
    "dertien",
    "veertien",
    "vijftien",
    "zestien",
    "zeventien",
    "achtien",
    "negentien",
  ];
  static const List<String> _wordsTens = [
    "",
    "",
    "twintig",
    "dertig",
    "veertig",
    "vijftig",
    "zestig",
    "zeventig",
    "tachtig",
    "negentig",
  ];

  /// Pre-computed map for compound numbers 21-99 (e.g., 21 -> "eenentwintig").
  /// Generated by [_generateTensUnits].
  static final Map<int, String> _wordsTensUnits = _generateTensUnits();

  /// Scale words (long scale variant used in Dutch). Key is power of 1000 index.
  /// 2: 10^6, 3: 10^9, 4: 10^12, etc.
  static const Map<int, String> _scaleWords = {
    2: "miljoen",
    3: "miljard",
    4: "biljoen",
    5: "biljard",
    6: "triljoen",
    7: "triljard",
    8: "quadriljoen",
    9: "quadriljard",
  };

  /// Generates the [_wordsTensUnits] map for numbers 21-99.
  /// Follows the Dutch "unit-en-ten" structure (e.g., "drie-ën-veertig").
  static Map<int, String> _generateTensUnits() {
    final map = <int, String>{};
    for (int t = 2; t <= 9; t++) {
      // Tens: 20-90
      String tenWord = _wordsTens[t];
      for (int u = 1; u <= 9; u++) {
        // Units: 1-9
        String unitWord = (u == 1) ? "een" : _wordsUnder20[u];
        // Use "ën" with units 2 and 3 for pronunciation/linking.
        String conjunction = (u == 2 || u == 3) ? "ën" : "en";
        map[t * 10 + u] = "$unitWord$conjunction$tenWord";
      }
    }
    return map;
  }

  /// Processes the given [number] into Dutch words.
  ///
  /// {@template num2text_process_intro}
  /// Normalizes input (`int`, `double`, `BigInt`, `Decimal`, `String`) to [Decimal].
  /// {@endtemplate}
  ///
  /// {@template num2text_process_options}
  /// Uses [NlOptions] for customization (currency, year format, decimals, AD/BC).
  /// Defaults apply if [options] is null or not [NlOptions].
  /// {@endtemplate}
  ///
  /// {@template num2text_process_errors}
  /// Handles `Infinity`, `NaN`. Returns [fallbackOnError] or "Geen Getal" on failure.
  /// {@endtemplate}
  ///
  /// @param number The number to convert.
  /// @param options Optional [NlOptions] settings.
  /// @param fallbackOnError Optional error string.
  /// @return The number as Dutch words or an error string.
  @override
  String process(
      dynamic number, BaseOptions? options, String? fallbackOnError) {
    final NlOptions nlOptions =
        options is NlOptions ? options : const NlOptions();
    final String errorFallback = fallbackOnError ?? "Geen Getal";

    if (number is double) {
      if (number.isInfinite)
        return number.isNegative ? "Negatieve Oneindigheid" : "Oneindig";
      if (number.isNaN) return errorFallback;
    }

    final Decimal? decimalValue = Utils.normalizeNumber(number);
    if (decimalValue == null) return errorFallback;

    if (decimalValue == Decimal.zero) {
      return nlOptions.currency
          ? "${_wordsUnder20[0]} ${nlOptions.currencyInfo.mainUnitPlural ?? nlOptions.currencyInfo.mainUnitSingular}"
          : _wordsUnder20[0];
    }

    final bool isNegative = decimalValue.isNegative;
    final Decimal absValue = isNegative ? -decimalValue : decimalValue;

    String textResult;
    if (nlOptions.format == Format.year) {
      // Note: Assumes year fits within standard int range for this specific handling.
      textResult = _handleYearFormat(
          decimalValue.truncate().toBigInt().toInt(), nlOptions);
    } else {
      textResult = nlOptions.currency
          ? _handleCurrency(absValue, nlOptions)
          : _handleStandardNumber(absValue, nlOptions);
      if (isNegative) {
        textResult = "${nlOptions.negativePrefix} $textResult";
      }
    }

    return textResult.replaceAll(RegExp(r'\s+'), ' ').trim();
  }

  /// Converts an integer year to Dutch words.
  ///
  /// Handles the common "X honderd Y" pattern for years 1100-1999.
  /// Other years use standard integer conversion. Appends AD/BC if requested.
  ///
  /// @param year The integer year.
  /// @param options Formatting options.
  /// @return The year as Dutch words.
  String _handleYearFormat(int year, NlOptions options) {
    final bool isNegative = year < 0;
    final int absYear = year.abs();
    String yearText;

    // Special handling for 1100-1999: "X honderd (Y)"
    if (absYear >= 1100 && absYear < 2000) {
      int highPart = absYear ~/ 100; // e.g., 19
      int lowPart = absYear % 100; // e.g., 84 or 0
      String yearHighText = _wordsUnder20[highPart]; // Use direct lookup
      if (lowPart == 0) {
        yearText = "$yearHighText$_hundred"; // e.g., "negentienhonderd"
      } else {
        yearText =
            "$yearHighText$_hundred ${_convertChunk(lowPart)}"; // e.g., "negentienhonderd vierentachtig"
      }
    } else {
      // Default to standard integer conversion for other years.
      yearText = _convertInteger(BigInt.from(absYear));
    }

    if (isNegative)
      yearText += " $_yearSuffixBC";
    else if (options.includeAD && year > 0) yearText += " $_yearSuffixAD";

    return yearText;
  }

  /// Converts a non-negative [Decimal] to Dutch currency words.
  ///
  /// Uses [NlOptions.currencyInfo] for unit names. Rounds if [NlOptions.round] is true.
  /// Separates main and subunits (e.g., euro, cent). Uses "en" as separator.
  ///
  /// @param absValue Absolute currency value.
  /// @param options Formatting options.
  /// @return Currency value as Dutch words.
  String _handleCurrency(Decimal absValue, NlOptions options) {
    final CurrencyInfo info = options.currencyInfo;
    // Assumes 2 decimal places for subunits (e.g., cents).
    final Decimal val = options.round ? absValue.round(scale: 2) : absValue;
    final BigInt mainVal = val.truncate().toBigInt();
    final BigInt subVal =
        ((val - Decimal.fromBigInt(mainVal)) * Decimal.fromInt(100))
            .truncate()
            .toBigInt();

    String mainPart = '';
    if (mainVal > BigInt.zero) {
      String name = (mainVal == BigInt.one)
          ? info.mainUnitSingular
          : (info.mainUnitPlural ?? info.mainUnitSingular);
      mainPart = '${_convertInteger(mainVal)} $name';
    }

    String subPart = '';
    if (subVal > BigInt.zero && info.subUnitSingular != null) {
      String name = (subVal == BigInt.one)
          ? info.subUnitSingular!
          : (info.subUnitPlural ?? info.subUnitSingular!);
      subPart = '${_convertInteger(subVal)} $name';
    }

    if (mainPart.isNotEmpty && subPart.isNotEmpty)
      return '$mainPart $_and $subPart';
    else if (mainPart.isNotEmpty)
      return mainPart;
    else if (subPart.isNotEmpty)
      return subPart; // Handle 0.xx cases
    else
      return "${_wordsUnder20[0]} ${info.mainUnitPlural ?? info.mainUnitSingular}"; // Zero case
  }

  /// Converts a non-negative standard [Decimal] number to Dutch words.
  ///
  /// Converts integer and fractional parts. Uses [NlOptions.decimalSeparator] word.
  /// Fractional part converted digit by digit, preserving leading zeros based on original scale.
  ///
  /// @param absValue Absolute decimal value.
  /// @param options Formatting options.
  /// @return Number as Dutch words.
  String _handleStandardNumber(Decimal absValue, NlOptions options) {
    final BigInt integerPart = absValue.truncate().toBigInt();
    final Decimal fractionalPart = absValue - absValue.truncate();
    final String integerWords =
        (integerPart == BigInt.zero && fractionalPart > Decimal.zero)
            ? _wordsUnder20[0] // Use "nul" for 0.xxx cases
            : _convertInteger(integerPart);

    String fractionalWords = '';
    // Process fractional part only if it exists and adds value (non-zero or part of 0.00).
    if (absValue.scale > 0 &&
        (fractionalPart > Decimal.zero || integerPart == BigInt.zero)) {
      String sepWord;
      switch (options.decimalSeparator) {
        case DecimalSeparator.point:
        case DecimalSeparator.period:
          sepWord = _point;
          break;
        default:
          sepWord = _comma;
          break; // Default to comma
      }

      // Extract fractional digits, scale matters for leading zeros.
      final BigInt digitsAsInt =
          (fractionalPart * Decimal.fromInt(10).pow(absValue.scale).toDecimal())
              .truncate()
              .toBigInt();
      final String digitsString = digitsAsInt.toString();
      // Ensure leading zeros are represented (e.g., 0.05 -> "nul vijf").
      final String paddedDigits = digitsString.padLeft(absValue.scale, '0');

      List<String> digitWords = paddedDigits.split('').map((d) {
        final int i = int.parse(d);
        return _wordsUnder20[i]; // Convert each digit 0-9
      }).toList();

      fractionalWords =
          ' $sepWord ${digitWords.join(' ')}'; // e.g., " komma nul vijf"
    }

    return '$integerWords$fractionalWords'.trim();
  }

  /// Converts a non-negative [BigInt] into Dutch words using scales.
  ///
  /// Breaks down numbers >= 1,000,000 using [_scaleWords] (miljoen, miljard, etc.).
  /// Delegates smaller parts to [_convertLessThanMillion].
  ///
  /// @param n Non-negative integer.
  /// @return Integer as Dutch words.
  /// @throws ArgumentError if [n] is negative or too large for defined scales.
  String _convertInteger(BigInt n) {
    if (n < BigInt.zero) throw ArgumentError("Input must be non-negative: $n");
    if (n == BigInt.zero) return _wordsUnder20[0];
    if (n < BigInt.from(1000000))
      return _convertLessThanMillion(n); // Handle < 1 million

    List<String> parts = [];
    BigInt remainder = n;
    // Start from the largest defined scale power (e.g., quadriljard 10^27 -> power 27).
    int scalePower = _scaleWords.keys.last * 3;

    while (scalePower >= 6) {
      // Iterate down to million (10^6)
      final BigInt scaleValue = BigInt.from(10).pow(scalePower);
      final int scaleIndex =
          scalePower ~/ 3; // Index for _scaleWords (2=miljoen, 3=miljard...)

      if (_scaleWords.containsKey(scaleIndex) && remainder >= scaleValue) {
        BigInt chunkCount = remainder ~/ scaleValue;
        remainder %= scaleValue;
        // Recursively convert the count of this scale unit.
        String chunkText = _convertInteger(chunkCount);
        String scaleWord = _scaleWords[scaleIndex]!;
        // Handle "één miljoen" vs "twee miljoen".
        if (chunkCount == BigInt.one && scaleIndex >= 2) {
          chunkText = _wordsUnder20[1]; // Use "één" instead of "een"
        }
        parts.add("$chunkText $scaleWord");
      }
      scalePower -= 3; // Move to the next smaller scale
    }

    // Convert the remaining part (less than a million).
    if (remainder > BigInt.zero) {
      parts.add(_convertLessThanMillion(remainder));
    }

    return parts.join(' ').replaceAll(RegExp(r'\s+'), ' ').trim();
  }

  /// Converts a [BigInt] [n] between 0 and 999,999 into Dutch words.
  ///
  /// Separates thousands and the remainder. Uses [_convertChunk] for parts.
  /// Handles "duizend" (1000) vs "tweeduizend" (2000), etc.
  ///
  /// @param n Integer < 1,000,000.
  /// @return Number as Dutch words, or empty string if [n] is 0.
  String _convertLessThanMillion(BigInt n) {
    if (n >= BigInt.from(1000000))
      throw ArgumentError("Number must be < 1,000,000: $n");
    if (n == BigInt.zero) return "";

    List<String> parts = [];
    final int thousandPart = (n ~/ BigInt.from(1000)).toInt(); // 0-999
    final int remainderPart = (n % BigInt.from(1000)).toInt(); // 0-999

    if (thousandPart > 0) {
      if (thousandPart == 1)
        parts.add(_thousand); // 1000 is just "duizend"
      else {
        // Combine number and thousand (e.g., "twee" + "duizend" -> "tweeduizend").
        // Note: _convertChunk returns "een" for 1, need "één" for >1000 counts? Tests say no.
        // Let's stick to "een" based on "eenentwintigduizend".
        parts.add("${_convertChunk(thousandPart)}$_thousand");
      }
    }

    if (remainderPart > 0) parts.add(_convertChunk(remainderPart));

    return parts.join(' ').trim();
  }

  /// Converts an integer from 0 to 999 into Dutch words.
  ///
  /// Handles hundreds, then the 0-99 part using lookups/maps.
  ///
  /// @param n Integer chunk (0-999).
  /// @return Chunk as Dutch words, or empty string if [n] is 0.
  /// @throws ArgumentError if [n] is outside 0-999.
  String _convertChunk(int n) {
    if (n == 0) return "";
    if (n < 0 || n >= 1000) throw ArgumentError("Chunk must be 0-999: $n");

    List<String> words = [];
    int remainder = n;

    // Handle hundreds.
    if (remainder >= 100) {
      int hundredMultiplier = remainder ~/ 100;
      // "honderd" for 100, "tweehonderd", "driehonderd", etc.
      words.add(hundredMultiplier == 1
          ? _hundred
          : "${_wordsUnder20[hundredMultiplier]}$_hundred");
      remainder %= 100;
    }

    // Handle remaining 0-99 part.
    if (remainder > 0) {
      String tensUnitsPart;
      if (remainder < 20)
        tensUnitsPart = _wordsUnder20[remainder]; // 0-19 lookup
      else if (remainder % 10 == 0)
        tensUnitsPart = _wordsTens[remainder ~/ 10]; // 20, 30...90 lookup
      else
        tensUnitsPart = _wordsTensUnits[remainder]!; // 21-99 map lookup
      words.add(tensUnitsPart);
    }

    return words.join(' ').trim();
  }
}
